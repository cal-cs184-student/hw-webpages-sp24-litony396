<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_m6m9sakog4s2-2{list-style-type:none}ul.lst-kix_m6m9sakog4s2-3{list-style-type:none}ul.lst-kix_m6m9sakog4s2-4{list-style-type:none}ul.lst-kix_m6m9sakog4s2-5{list-style-type:none}ul.lst-kix_m6m9sakog4s2-0{list-style-type:none}ul.lst-kix_m6m9sakog4s2-1{list-style-type:none}.lst-kix_m6m9sakog4s2-1>li:before{content:"\0025cb   "}.lst-kix_m6m9sakog4s2-7>li:before{content:"\0025cb   "}ul.lst-kix_m6m9sakog4s2-6{list-style-type:none}ul.lst-kix_m6m9sakog4s2-7{list-style-type:none}ul.lst-kix_m6m9sakog4s2-8{list-style-type:none}.lst-kix_m6m9sakog4s2-0>li:before{content:"\0025cf   "}.lst-kix_m6m9sakog4s2-8>li:before{content:"\0025a0   "}.lst-kix_m6m9sakog4s2-3>li:before{content:"\0025cf   "}.lst-kix_m6m9sakog4s2-5>li:before{content:"\0025a0   "}.lst-kix_m6m9sakog4s2-2>li:before{content:"\0025a0   "}.lst-kix_m6m9sakog4s2-6>li:before{content:"\0025cf   "}.lst-kix_m6m9sakog4s2-4>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c11{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c1{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c9{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Times New Roman";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Times New Roman";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Times New Roman";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c6{-webkit-text-decoration-skip:none;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman"}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c8{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c13{font-size:16pt;font-family:"Times New Roman";font-weight:700}.c10{font-size:13pt;font-family:"Times New Roman";font-weight:700}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c12 doc-content"><p class="c4"><span class="c13">CS184 HW2: MeshEdit</span></p><p class="c4"><span class="c10">Overview</span></p><p class="c3"><span class="c2">In this assignment, we are asked to implement a mesh editor. First, we implement functions which draw both bezier curves and bezier surfaces through the use 1D de Casteljau subdivision. Then, we add the ability to calculate area-weighted vertex normals in order to implement Phong shading. Next, we add the ability to manipulate edges on the mesh by coding up functions to flip and split edges on a mesh. Finally, these flip and split functions are used to implement Loop Subdivision in order to upsample meshes. I thought it was interesting that simple actions such as edge flipping and edge splitting is able to upsample a mesh to look so much better. </span></p><hr style="page-break-before:always;display:none;"><p class="c3 c5"><span class="c2"></span></p><p class="c4"><span class="c10">Task 1: Bezier Curves with 1D de Casteljau Subdivision</span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3"><span class="c2">The de Casteljau algorithm is a simple algorithm which takes in n control points and a parameter t. In every line of consecutive points, you can do a linear interpolation between the 2 points using t as the ratio that you take from each point. Specifically, this lerp = &#8203;(1 - t)p0 + tp1, which is just a linear combination of the first point p0 and the second point p1. . You can repeat this process with the new points that you get until you go down to one point which is on the desired bezier curve. In order to implement this algorithm, the evaluteStep() function was written. This function does one of the steps of the above algorithm by doing all the lerps with the given points and parameter t. This can be recursively called until a single point is left, at which point you have a point on the curve. You can vary the t parameter from 0 to 1 in order to get the full curve.</span></p><p class="c3 c5"><span class="c2"></span></p><p class="c4"><span class="c1">Step 0</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 418.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 418.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c2"></span></p><p class="c4"><span class="c1">Step 2</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c5"><span class="c2"></span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c1"></span></p><p class="c4"><span class="c1">Step 3</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 418.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 418.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Step 4</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image21.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c1">Step 5</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image26.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Step 6</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Effect of Control Points and t-value</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Changing the position of the control points affects the shape of the curve. Varying t will change where the red dot is. This makes sense since t is a main component of how the lerps are evaluated (which are linear combinations of adjacent points), so changing the ratio t will change the position on the bezier curve which you are evaluating.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c10">Task 2: Bezier Surfaces with Separable 1D de Casteljau</span></p><p class="c3 c5"><span class="c2"></span></p><p class="c3"><span class="c2">When trying to render a Bezier surface, you are given an n x n array of control points. In order to use 1D de Casteljau to draw a surface point, you can just do the same algorithm as task 1 on each of the rows of your array using the same t parameter for each row. This gives you n distinct points on bezier curves in 3D space. You can then interpolate between these new sets of points in order to form points on the bezier surface with another parameter v. This interpolation gives you another degree of freedom which makes the previously 2D curve in Task 1 a 3D surface instead. You can vary all combinations of t and v from 0 to 1 in order to draw the full bezier surface. In order to implement this in code, I just call the same algorithm used to create the bezier curves in task 1 for every row of my control point array, all with the same parameter t. Then, I run the same algorithm one last time with the points I collected from these applications of the task 1 algorithm with parameter v in order to get a final point.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 418.67px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 418.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c9">Task 3: Area Weighted Vertex Normals</span></p><p class="c4 c5"><span class="c2"></span></p><p class="c3"><span class="c2">Given a vertex v, to calculate its area weighted normal, you have to sum the normals of each surrounding face weighted by its area. I did this by looping over all the halfedges originating from v and doing some work with each halfedge. At each halfedge, I take the ending vertex of it and the next halfedge originating from v in order to make two vectors a and b, both with origin v. These two vectors are vectors of a face that is next to v. With them, I can take the cross product of them in order to get a normal of the face they are associated with. The area of the triangle can be calculated by dividing this normal by 2 (according to StackExchange). So, I just subtract it (in order to get the normals to point toward the exterior of the model) from the accumulator vector, weighting it by this area. Finally, the accumulator is normalized and returned.</span></p><p class="c4"><span class="c6">Normals Off</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Normals On</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 414.67px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 414.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c10">Task 4: Edge Flip</span></p><p class="c4 c5"><span class="c2"></span></p><p class="c3"><span class="c2">I implemented edge flips by drawing out a diagram of the operation and then figuring out all the pointer reassignments I would need to do. After this, I made variables for all the necessary vertices, halfedges, and faces. Then, I reassigned the pointers according to my diagram. Because of this, my implementation worked on the first try and I do not have a debugging journey to share.</span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c2"></span></p><p class="c4"><span class="c6">Edge Flip Diagram</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 806.67px;"><img alt="" src="images/image13.jpg" style="width: 624.00px; height: 806.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c2"></span></p><p class="c4"><span class="c6">Pre-Flip</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 408.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 408.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c1"></span></p><p class="c4"><span class="c6">Post-Flip</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image25.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c2"></span></p><p class="c4"><span class="c10">Task 5: Edge Splits</span></p><p class="c4 c5"><span class="c2"></span></p><p class="c3"><span class="c2">I implemented edge splits the same way I implemented edge flips. I drew a diagram and then just copied all of my pointer reassignments into code. Before the reassignments, I also created all the new elements that were required to perform the edge split. Specifically, I had to create 2 new faces, 3 new edges, 6 new half edges, and one new vertex. My code worked on the first try again so I have no eventful debugging journey.</span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c2"></span></p><p class="c4"><span class="c6">Edge Split Diagram</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 806.67px;"><img alt="" src="images/image22.jpg" style="width: 624.00px; height: 806.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Before Splits and Flips</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image28.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">After Splits, Before Flips</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 413.33px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">After Splits and Flips</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 414.67px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 414.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c10">Task 6: Loop Subdivision for Mesh Upsampling</span></p><p class="c4 c5"><span class="c2"></span></p><p class="c3"><span class="c8">I implemented loop subdivision by using the process given in the project spec. First, I iterated through all the vertices in the mesh and then calculated their new position by going through each vertex&rsquo;s neighboring vertices, setting isNew to false and storing the new position in the newPosition variable for the vertex. Then, I iterated through all edges and calculated and stored in newPosition the new position for the new vertex post-split as well as setting isNew to false. Then I went through all the edges again, calling splitEdge on it if the edge is not new and is not the result of splitting an old edge during the course of this loop. splitEdge was also modified to set the isNew variables of the new vertex and the two new edges which were not part of the split of the original edge to true. Afterwards, I iterated through all the edges again, flipping it if exactly one of the vertices it connects was new. Then, I iterated through all the vertices, setting each one&rsquo;s position to newPosition.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - No Subdivision</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 412.00px;"><img alt="" src="images/image29.png" style="width: 624.00px; height: 412.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">The edges and corners on the outer ring of the model are really sharp in this model. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - One Subdivision</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 413.33px;"><img alt="" src="images/image20.png" style="width: 624.00px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">After one subdivision, the model becomes a lot more rounded, now actually looking like a ring. The number of triangles in the mesh have notably increased. We can see that the subdivision makes the sharp edges rounded and collapsed. The curves are not perfectly round yet and are still pretty blocky and sharp.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Two Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Again, another level of subdivision makes the model a lot more rounded. There are a lot more triangles but you can still see some blockiness as you transition from different distances from the center of the ring. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Three Subdivisions</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">The ring continues to become smoother. The transition as you move away from the center of the ring becomes more slight and gradual than the previous picture.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Four Subdivisions</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">This ring looks extremely smooth and you can barely notice the transition as you move farther from the center now. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Pre-Split - No Subdivision</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 413.33px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">I presplit the edges on the very edges of the ring in order to try and make the rounding effect of mesh subdivision worse.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Pre-Split - One Subdivision</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">The ring is noticeably more wobbly than if I did not pre split the edges. The pre-split edges limit the effect that the subdivision has on the roundedness of the model. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Torus - Pre-Split - Four Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Even at four subdivisions, the ring is still noticeably bumpy. The mesh subdivision cannot round these out because the edge splits made a physical change to the model that made it more bumpy on the edges. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Cube - No Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 413.33px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c4 c5"><span class="c2"></span></p><p class="c4"><span class="c1">Cube - Three Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 414.67px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 414.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">After a few subdivisions, the cube becomes asymmetrical as you move towards each of the corners. This is not what we expect intuitively since cubes are supposed to be symmetrical. This is because each cube face only has one diagonal edge. This makes the mesh upsampling imbalance in different directions as each face only has an asymmetrical edge layout to work on, causing an asymmetric output.</span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Cube - Pre-Split - No Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image24.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">&nbsp;</span></p><p class="c3"><span class="c8">In order to address the issue from before, I make each cube face have a symmetrical arrangement of edges by splitting every diagonal on every face. </span><hr style="page-break-before:always;display:none;"></p><p class="c4"><span class="c6">Cube - Pre-Split - Three Subdivisions</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 413.33px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2">After upsampling a few times, we can see that the model is symmetrical. When you move away from the center of the face, it is now an equal change no matter which direction you go.</span></p></body></html>
