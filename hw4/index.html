<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_nmuq5zlkk4vi-8{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-7{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-6{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-5{list-style-type:none}.lst-kix_nmuq5zlkk4vi-4>li:before{content:"\0025cb   "}ul.lst-kix_nmuq5zlkk4vi-4{list-style-type:none}.lst-kix_nmuq5zlkk4vi-5>li:before{content:"\0025a0   "}ul.lst-kix_nmuq5zlkk4vi-3{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-2{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-1{list-style-type:none}ul.lst-kix_nmuq5zlkk4vi-0{list-style-type:none}.lst-kix_nmuq5zlkk4vi-2>li:before{content:"\0025a0   "}.lst-kix_nmuq5zlkk4vi-3>li:before{content:"\0025cf   "}.lst-kix_nmuq5zlkk4vi-6>li:before{content:"\0025cf   "}.lst-kix_nmuq5zlkk4vi-7>li:before{content:"\0025cb   "}.lst-kix_nmuq5zlkk4vi-0>li:before{content:"\0025cf   "}.lst-kix_nmuq5zlkk4vi-1>li:before{content:"\0025cb   "}.lst-kix_nmuq5zlkk4vi-8>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Times New Roman";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c1{-webkit-text-decoration-skip:none;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman"}.c11{font-weight:400;text-decoration:none;font-size:13pt;font-family:"Times New Roman"}.c9{font-size:13pt;font-family:"Times New Roman";font-weight:700}.c5{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c12{font-size:16pt;font-family:"Times New Roman";font-weight:700}.c8{color:#000000;vertical-align:baseline;font-style:normal}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10 doc-content"><p class="c2"><span class="c12">CS184 HW4: Clothsim</span></p><p class="c2"><span class="c4">Overview</span></p><p class="c7"><span class="c5">In this assignment, we are asked to implement a cloth simulation program. First, we create a grid of evenly spaced point masses as well as springs between these point masses in order to create the cloth. Then, we add basic physics to the simulation by calculating the forces on each point from external accelerations such as gravity and forces from the springs in the cloth. This information is used with Verlet integration in order to calculate the next position of that point mass in the cloth. Next, we add support for the cloth to collide with two objects, spheres and planes. Furthermore, we also add support for point masses to collide with other point masses, which makes the simulation more realistic as two point masses cannot occupy the same space. Finally, we write GLSL shaders in order to add effects to our cloth such as shading or applying a texture.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Part 1: Masses and Springs</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">This grid of point masses was implemented by evenly spreading out num_width_points * num_height_points across the lengths of width and height. This was done by first dividing width or height by (num_width_points - 1) or (num_height_points - 1) respectively. This gives us the space between each point in each direction which lets us just iterate through the points we have to make, adding these distances each time to get the correct positions, marking the mass pinned if it is indicated as such. Regarding the positions, if the cloth is horizontal, the y position is set to 1 while the distances are used to calculate the x and z coordinates. If the cloth is vertical, then we instead vary over the x and y coordinates and make the z value a random number between -1/1000 and 1/1000. This is generated by making a random number, modulo dividing by 2001, dividing by 1000000, then subtracting 1 / 1000. Finally, in order to create the springs between point masses in the cloth, the program iterates through all the created point masses and makes structural constraints with the left and top point masses, shearing constraints with the top left and top right point masses, and bending constraints with point masses 2 to the left and 2 upwards. Springs with point masses that do not exist (edge cases) are ignored and not created. </span></p><p class="c2"><span class="c1">Pinned2</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 452.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 452.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c3"><span class="c0"></span></p><p class="c2"><span class="c1">Pinned2 - No Shearing Constraints</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 488.00px;"><img alt="" src="images/image31.png" style="width: 624.00px; height: 488.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c3"><span class="c0"></span></p><p class="c2"><span class="c1 c8">Pinned2 - Only Shearing Constraints</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 452.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 452.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Pinned2 - All Constraints</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 452.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 452.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Part 2: Simulation via Numerical Integration</span></p><p class="c3"><span class="c0"></span></p><p class="c2"><span class="c1">Pinned4 - Final Resting State - Default Parameters</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c6"><span class="c1 c8"></span></p><p class="c2"><span class="c1 c8">Pinned4 - Final Resting State - ks = 1</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 341.33px;"><img alt="" src="images/image21.png" style="width: 624.00px; height: 341.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Pinned4 - Final Resting State - ks = 100000</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 304.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 304.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">As the spring constant decreases, the spring force decreases, making the mesh sag more and more limp. When played from start to rest, the mesh becomes a lot bouncier, making a lot of large waves when the pinned masses start to stop the mesh from falling. As the spring constant increases, the spring force increases, which makes the mesh tighter and sag less. When played from start to rest, the bounce up from when the pinned masses stop the mesh from falling make really small waves. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Pinned4 - Final Resting State - Density = 1</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 254.67px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 254.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Pinned4 - Final Resting State - Density = 5000</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 288.00px;"><img alt="" src="images/image26.png" style="width: 624.00px; height: 288.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">As the density decreases, the gravitational force decreases, which makes the mesh sag less since the spring forces are equal to the gravitational forces earlier. The mesh makes small waves when it gets to the point where it stops falling. As the density increases, the gravitational force increases, which makes the mesh sag more since the spring forces have to be greater to counteract the gravitational forces. The mesh makes large waves when it stops falling. This is interesting as it has the same effects as changing the spring constant but in an inverse way.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1 c8">Pinned4 - Initial Bounce from Falling and Stopping - Damping = 0.05</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 344.00px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 344.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">The damping value does not affect the final resting state, it affects how long it takes to get to a resting state. A low damping value makes the magnitude of the waves of the mesh when it reaches the stopping point really large and makes those waves lose magnitude at a very slow rate. It also makes the initial fall of the mesh much faster. A high damping value makes the magnitude of the waves really small or nonexistent as well as making the initial fall really slow. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Part 3: Handling Collisions With Other Objects</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">Collision with the sphere first involves calculating a vector going from the origin of the sphere to the current position of the point mass. If this vector has a norm greater than the radius of the sphere, there was no intersection so the point mass should be ignored. Otherwise, the tangent point is found by moving along this origin to position vector for (radius - this vector&rsquo;s norm) units to get to where the point mass passed through the sphere initially. Then, the position of the point mass is set to the last position of the point mass moving toward this tangent point, scaled down slightly by a friction value. </span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">Collision with the plane first checks that the last position and current position of the point mass are on opposite sides of the sphere. This is done by making vectors from a point on the plane to those positions and then taking a dot product with the normal of the plane. If these two values are both positive or both negative, then there was no intersection. Otherwise, the tangent point can be calculated by moving from the current position of the point mass along the normal of the plane to a point on the plane itself. Then, a correction vector is made from the last position of the point mass to the tangent point. Furthermore, a vector made in the direction of the normal on the plane (on the side of the last position) is made with the magnitude of the given surface offset and is added to the correction vector. The final position is then the result of the applying the correction vector to the last position of the point mass scaled down by the friction value. </span></p><p class="c3"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c6"><span class="c1 c8"></span></p><p class="c2"><span class="c1 c8">Sphere Collision - ks = 5000</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.00px; height: 476.00px;"><img alt="" src="images/image1.png" style="width: 601.00px; height: 476.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Sphere Collision - ks = 500</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 548.00px; height: 521.00px;"><img alt="" src="images/image29.png" style="width: 548.00px; height: 521.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">Lowering the spring constant lowers the spring force, which makes the cloth droop down lower while resting on the sphere. The cloth is more stretched out than the ks = 5000 case.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Sphere Collision - ks = 50000</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 464.00px;"><img alt="" src="images/image32.png" style="width: 624.00px; height: 464.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">Increasing the spring constant makes the resting state of the cloth much more rigid. It does not droop down as much as the ks = 5000 case, instead some of the sides of the cloth are lifted up more. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Plane Collision (Light Green Is Plane)</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 364.00px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 364.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c4">Part 4: Handling Self-Collisions</span></p><p class="c2 c6"><span class="c0"></span></p><p class="c7"><span class="c0">Self-collision was done with the head of a hashmap of all the point masses based on their positions. A hashing function was made which split the screen into a bunch of equal sized boxes, with the box that you are in being used to group positions into one hash value. The has value itself was made by taking the position of that box in the 3D grid of boxes, then summing up the x, y, and z coordinates of that position. In order to make the hashes unique, each of these coordinates is multiplied by a different prime number.</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">Then, using this hashing function, the hashmap is created by iterating through all the point masses and putting them into the hashmap based on the hashing function.</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c5">Finally, the self collision function is called on every point mass, which generates a correction vector for each candidate point mass too close to the current point mass. The candidate point masses are the ones which are in the same vector of the hashtable as the current point mass. The correction vector moves the current point mass away from the candidate point mass. The correction vector for every colliding point mass is then averaged in order to be added to the current position to find the correct position.</span></p><p class="c2"><span class="c1">Initial Self-Collision</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 434.67px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 434.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Later Self-Collision</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 446.67px;"><img alt="" src="images/image34.png" style="width: 624.00px; height: 446.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c6"><span class="c4"></span></p><p class="c2"><span class="c1">Resting State After Self-Collision</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 302.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 302.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Self-Collision with Density = 1</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 405.16px;"><img alt="" src="images/image33.png" style="width: 624.00px; height: 495.00px; margin-left: 0.00px; margin-top: -89.84px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1">Self-Collision with Density = 30</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 338.67px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 338.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c6"><span class="c0"></span></p><p class="c2 c6"><span class="c0"></span></p><p class="c7"><span class="c5">As density increases, the number of self-collisions increases. As shown in the pictures, a lower density causes the cloth to fold into itself less times while a higher density causes the cloth to fold into itself more. This increases the number of self-collisions since each fold causes point masses to collide with each other. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Self-Collision with ks = 1000</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 301.33px;"><img alt="" src="images/image24.png" style="width: 624.00px; height: 301.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c8">Self-Collision with ks = 100000</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 394.67px;"><img alt="" src="images/image30.png" style="width: 624.00px; height: 394.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">As the spring constant increases, the number of self-collisions decreases. As shown in the pictures, a lower spring constant results in an effect similar to when you increase density as the spring folds onto itself more, causing more self-collisions. With a higher spring constant, there are less folds which means less self-collisions.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Part 5: Shaders</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">A shader program is a program which can change the geometry or the color of an object in a scene in order to achieve some visual effect such as lighting effects or bumps on the object. Vertex shaders are used to choose the position of a pixel / vertex of the object and funnel info about the pixel to the fragment shader. These shaders are used to create visual effects that require shifting the positions of pixels in an object, so it is in charge of the geometric effects. Fragment shaders use its input from the vertex shader in order to determine the color of the pixel on the object. So, these shaders control the lighting effects by choosing the correct color using some lighting scheme. This is not limited to just lighting effects as you can do other things such as apply textures to the object.</span></p><p class="c3"><span class="c0"></span></p><p class="c7"><span class="c0">The Blinn-Phong shading model creates realistic lighting by combining 3 different and simple lighting details. First, there is ambient shading, which is constant shading added to the scene. Then, there is diffuse shading, which is shading that does not depend on which direction the light is coming from. Finally, there is specular shading, which does depend on light and creates a reflective finish towards the direction of the light source.</span></p><p class="c3"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c6"><span class="c1 c8"></span></p><p class="c2"><span class="c1">Blinn-Phong - Ambient Only</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 525.33px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 525.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Blinn-Phong - Diffuse Only</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 611.00px; height: 619.00px;"><img alt="" src="images/image8.png" style="width: 611.00px; height: 619.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Blinn-Phong - Specular Only</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 611.00px; height: 636.00px;"><img alt="" src="images/image23.png" style="width: 611.00px; height: 636.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Blinn-Phong - All Shading</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 582.00px; height: 597.00px;"><img alt="" src="images/image9.png" style="width: 582.00px; height: 597.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Texture Mapping Shader</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 609.33px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 609.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Bump Mapping - Cloth</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 638.67px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 638.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Bump Mapping - Sphere</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 604.00px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 604.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Displacement Mapping - Sphere</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 564.00px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 564.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">Bump mapping just applies the texture directly to the image in order to make it look like there is a height difference while the geometry stays the same. Displacement mapping both applies the texture and changes the actual geometry of the object as shown by the squares on the sphere being at different heights. Looking at the displacement mapping sphere, there are actual dents and peaks in the sphere while the bump mapping sphere is still a perfect sphere.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Bump Mapping - Sphere - Coarse - o, a = 16</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 549.33px;"><img alt="" src="images/image22.png" style="width: 624.00px; height: 549.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Displacement Mapping - Sphere - Coarse - o, a = 16</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 594.67px;"><img alt="" src="images/image20.png" style="width: 624.00px; height: 594.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Bump Mapping - Sphere - Smooth - o, a = 128</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 587.00px; height: 577.00px;"><img alt="" src="images/image17.png" style="width: 587.00px; height: 577.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Displacement Mapping - Sphere - Smooth - o, a = 128</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 589.33px;"><img alt="" src="images/image25.png" style="width: 624.00px; height: 589.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c5">We can see that the bump mapping in both the coarse and smooth cases look pretty much the same. However, displacement mapping can take more advantage of the smooth case as it has more detail. The changing heights on the sphere are more defined in the smooth case and are easy to notice. In the coarse case, the displacement was difficult to see since it was so slight. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c1">Mirror Shader - Cloth</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 610.67px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 610.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c6"><span class="c0"></span></p><p class="c2"><span class="c1">Mirror Shader - Sphere</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 472.00px; height: 428.00px;"><img alt="" src="images/image28.png" style="width: 472.00px; height: 428.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>