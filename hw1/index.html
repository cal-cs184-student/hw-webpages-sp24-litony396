<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Times New Roman";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c10{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c14{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c7{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c4{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c11{-webkit-text-decoration-skip:none;text-decoration:underline;text-decoration-skip-ink:none}.c16{font-weight:400;font-size:16pt;font-family:"Times New Roman"}.c13{font-size:16pt;font-family:"Times New Roman";font-weight:700}.c9{font-size:13pt;font-family:"Times New Roman";font-weight:700}.c15{font-weight:400;font-size:11pt;font-family:"Arial"}.c8{color:inherit;text-decoration:inherit}.c5{height:11pt}.c12{color:#1155cc}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c4 doc-content"><div><p class="c0"><span class="c14 c15"></span></p></div><p class="c2"><span class="c13">CS184 HW1: Rasterizer</span></p><p class="c2"><span class="c9 c14">Task 1: Drawing Single-Color Triangles</span></p><p class="c0"><span class="c6"></span></p><p class="c3"><span class="c1">To rasterize triangles, I calculate A, B, and C of the line equation (L(x,y) = Ax + By + C) of the three lines of the triangle (P0-&gt;P1, P1-&gt;P2, P2-&gt;P0). Then, I evaluate these three line equations for each point in the bounding box of the triangle (in order to fit the constraints on the pixels we are allowed to check), filling the pixel if all of the line equations are &gt;= 0 or &lt;= 0. I check that they&#39;re either &gt;= 0 or &lt;= 0 in order to make winding order irrelevant because going a different direction just flips the sign. This doesn&#39;t fill additional pixels because the line equations only satisfy this condition when the point is inside the triangle.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">This image is interesting because it shows the jaggies present in the image because no antialiasing has been implemented yet.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c9">Task 2: Antialiasing by Supersampling</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">My algorithm samples like it does in Task 1 with a higher resolution image and then downsamples the high-res image to the correct size. This supersampling algorithm uses the sample buffer as its only additional data structure. The sample buffer is made to be (sample_rate) times larger than the frame buffer: (width * height * sample_rate).</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">I modified the 3rd step of the rasterization pipeline since I had to make it write to the correct pixels on the enlarged sample buffer in fill_pixel() and rasterize_triangle(). In fill_pixel(), I had to modify it to work with the higher resolution since rasterize_point() and rasterize_line() were not antialiased. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">I also modified the 5th step of the pipeline by changing resolve_to_framebuffer(). I changed it by adding in a section which downsamples the sample_buffer and places the resulting pixel color in the correct place. I downsample by averaging the pixels inside of the section which corresponds to a particular pixel in the frame buffer.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">I used supersampling to antialias the triangles by first changing rasterize_triangle() to multiply the coordinates of the triangle by sqrt(sample_rate). This upscales the triangle to be placed in the correct area of the sample_buffer so that it is mapped to the correct position once downsampling happens. Then, I just kept the same algorithm as part 1 except I had to change the indexing to place the pixel by making it place it at (y * width * sqrt(sample_rate) + x) rather than just (y * width + x) to reflect the change in the sample_buffer&#39;s size. This indexing was very important to figure out as not adjusting it will cause the mapping between frame_buffer and sample_buffer to not be 1 to 1 or incorrect. </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c10 c7"></span></p><p class="c2"><span class="c10 c7">Sample Rate 1</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">In this image, you can clearly see the jaggies present in the red triangle because no antialiasing is being applied. Since the code just colors each pixel to be the max intensity of the given color, there is no blurring of edge pixels which are made from parts of the triangle which may not completely fill that pixel. </span></p><hr style="page-break-before:always;display:none;"><p class="c2 c5"><span class="c10 c7"></span></p><p class="c2"><span class="c10 c7">Sample Rate 4</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">In this picture, the triangle&rsquo;s edges are faded out more to create a smoother looking triangle. This works since the supersampling figures out how much of the triangle is outside of a pixel in higher dimensional space then averages it down to the downsampled version. This makes each pixel show different degrees of how much of that pixel is &ldquo;covered&rdquo; by the triangle by lightening the color.</span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c7 c11">Sample Rate 16</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1">Having a sample rate of 16 shows the same effect as sample rate 4 but with more complexity. Specifically, the decreasing color intensity in the edges is much more gradual than before. This is because using a sample rate of 16 uses an even higher dimensional sample buffer than sample rate 4 and thus is able to be more specific about how much each pixel in the low dimensional image is actually inside of the triangle.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c9">Task 3: Transforms</span></p><p class="c0"><span class="c6"></span></p><p class="c3"><span class="c7">For this section, I just return the transformation matrices which are given in </span><span class="c7 c11 c12"><a class="c8" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp24/lecture/4-26/transforms&amp;sa=D&amp;source=editors&amp;ust=1707893405999632&amp;usg=AOvVaw3WBB9qVTvdosXO5XU44C8_">lecture</a></span><span class="c1">.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image8.jpg" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c7">In this picture, cubeman jumps forward and tries to fly like superman. This picture is taken mid-descent.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Task 4: Barycentric Coordinates</span></p><p class="c0"><span class="c6"></span></p><p class="c3"><span class="c7">Barycentric coordinates is basically a position given in the triangle by taking a linear combination of fractions of each point of the triangle. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">This can be shown with this image of a triangle colored with barycentric coordinates. If you were to take some point in the bottom right area of the triangle, you could use barycentric coordinates to say that it could be 25% of the top left point, 25% of the bottom left point, and 50% of the bottom right point. This would describe that specific point of the triangle in barycentric coordinates. This is useful since you can use these percentages to say the percentage of the color of each point and then combine it into one color using the same barycentric coordinate calculation as shown in the picture.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Task 5: &ldquo;Pixel Sampling&rdquo; for Texture Mapping</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Pixel sampling is essentially just using barycentric coordinates to figure out what part of the texture maps to the pixel of the triangle we are trying to fill in and placing some function of that part of the texture in that pixel. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">This was implemented by using the same barycentric coordinates calculations as part 4 except it uses the uv coordinates given by the function rather than colors of the vertices. These uv coordinates give us a triangle in texture space so the barycentric coordinates map our current pixel&rsquo;s relative position in the screen space triangle to its relative position in the texture space triangle. The sample_nearest() and sample_bilinear() functions then use this relative position to calculate the texel they want to sample at and return a color which is a function of that texel/surrounding texels.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The nearest sampling method just looks at the continuous texel value that it is given and rounds to the closest position in the texture that is an integer value in order to actually access a valid texel in the texture. When coding this method, I ran into trouble in the bottom and right edges of the texture as it would sometimes round texel_x and texel_y to the width or height value of the texture, causing index errors. To fix this, I just set it to width - 1 or height - 1 when these values are rounded incorrectly.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The bilinear sampling method looks at the closest 4 integer texels which are surrounding our continuous texel value and does a few lerps (using the continuous texel position) between the colors stored at these texel locations to output a combination of the color of these texels. It does horizontal lerps from the bottom left pixel to the bottom right pixel and top left pixel to the top right pixel to get a bottom color and top color. Then, a final lerp is done from the top color to the bottom color in order to vertically average the two colors. While implementing bilinear sampling, I also had to deal with edge cases, when 4 texels didn&#39;t surround the continuous texel position. If in a corner, then I just returned the corner texel. If at the top or bottom edge, I just did one horizontal lerp. If at the left or right edge, I just did one vertical lerp.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Bilinear will do better than nearest when used in an area with a rapid change in color. This is because this area has high frequency information. The nearest algorithm won&rsquo;t be able to approximate this information very well but the bilinear algorithm will average surrounding values in order to deal with the high frequency better. </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c10 c7"></span></p><p class="c2"><span class="c7 c11">Nearest (Sample Rate 1)</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1">In this pixel inspector, you can see that the pillars of the windows of the Campanile are discontinuous with its white coloring. The pillars have a decent amount of black on them. This is because nearest just rounds to the nearest texel. Since there&rsquo;s a lot of dark pixels from the inside of the campanile, the algorithm sometimes rounds the pixel to a nearby texel that is just black rather than be white to make the pillar look nice. This is because of the high frequency information around this part of the image since it quickly switches from white to black. </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c10 c7"></span></p><p class="c2"><span class="c7 c11">Nearest (Sample Rate 16)</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1">Because of the increased resolution image from a higher sample rate, the pillars of the campanile windows now look nice and continuous. This is because the nearest rounding choices don&rsquo;t matter as much due to the supersampling algorithm averaging the pixel colors while downsampling anyway.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c10 c7"></span></p><p class="c2"><span class="c7 c11">Bilinear (Sample Rate 1)</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1">Here, we can see that the window pillars are much more continuous than when nearest sampling was used. This is because the bilinear algorithm averages the surrounding texel colors which deals with the rapid change in color from white to black. </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0"><span class="c7 c10"></span></p><p class="c2"><span class="c7 c11">Bilinear (Sample Rate 16)</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">This image looks pretty much the same as the nearest sampling with sample rate 16. This is because supersampling is better at dealing with high frequency information since it raises the resolution. Supersampling overshadows both bilinear and nearest sampling at the cost of efficiency. </span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c9">Task 6: &ldquo;Level Sampling&rdquo; with Mipmaps for Texture Mapping</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Level sampling basically chooses to use lower resolution versions of the texture in areas where the space being colored in screen space is really small but the area in texture space is really large. This causes too many texels to be mapped to each pixel in the image. Using lower resolution textures lessens the number of texels mapped to that pixel which makes it a lot less blurry.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">I implemented level sampling by first calculating the mipmap level using the standard mipmap level calculation (clamping the output value to be in between 0 and the maximum mipmap level). For nearest sampling, I just round the mipmap level to the nearest integer and pass it into the nearest or bilinear sampling functions depending on the pixel sampling method. Linear sampling is really similar except I sample two different colors with the two mipmap levels you get from rounding the level up or down (using the appropriate pixel sampling function). Using these two colors, I then return a lerp between them using the continuous mipmap level. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">From what I can see, pixel sampling seems to have the least noticeable effect on the quality of the image compared to supersampling and level sampling. Switching from nearest to bilinear makes a little bit of difference but the change is not very drastic. However, it is very cheap since it just requires a couple of lerps to achieve which makes it fast and not very memory intensive. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Level sampling is very good for a cheap price. Just by turning on any form of level sampling, the image quality increases a lot, far surpassing the pixel sampling methods. However, it does tend to over blur the image sometimes. In areas of an image which use the maximum mipmap level, it is noticeably blurry because it may need a higher level which doesn&rsquo;t exist. This method is very cheap in terms of speed as nearest only requires a mipmap level calculation and linear just requires an extra lerp. However, this has worse memory usage than pixel sampling as you have to store the lower resolution version of the texture.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c7">Supersampling is the best option for image quality. The image looks great just by turning up the sample rate a little bit. However, it has the worst speed and worst memory usage as it has to fill and store a higher resolution image as well as downsample it.</span><hr style="page-break-before:always;display:none;"></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c7 c11">L-Zero and P-Nearest</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">The golden staff has some jaggies as it doesn&rsquo;t fade its colors very well at the edges.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c7 c11">L-Zero and P-Linear</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">Turning on bilinear sampling makes the end of the staff look smoother by smoothing out the color transition.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c7 c11">L-Nearest and P-Nearest</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7">The algorithm uses a high mipmap level here which makes the staff look blurrier up close because it is using a lower-resolution texture. You can still see the jaggies that show up when level sampling uses L_zero instead.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span class="c7 c11">L-Nearest and P-Linear</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1">The staff uses a lower resolution texture and the bilinear sampling makes it look smoother around the edges like before. </span></p></body></html>